package com.wsq.edu.algorithm.array;

/**
 *
 * 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。
 *
 * 说明：
 *
 * 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？
 *
 *
 * @author xyzzg
 * @version 1.0
 * @date 2019-12-31 10:31
 */
public class SingleNumberArray {

    public int singleNumber(int[] nums) {

        /**
         * 就是用异或进行运算。因为数组中除了一个元素只出现一次之外，其它的元素都出现两次，
         * 如果把所有的数都异或，相同的数字异或为0，
         * 最后只剩下出现一次的数字，它和0异或，结果就是它本身。
         */
        int once = 0;
        for(int i = 0; i < nums.length; i++){
            once = once ^ nums[i];
        }
        return once ;
    }
    //之前一直以为异或运算是两个数的运算，比如3^8=1,2^2=0,现在才发现异或是位的运算，3的二进制是0011，而8的二进制数是1000，所以3^8=11（二进制位1011），比如-2^-3=3（三位可以表示0~7，也可以表示-4~3，其中111是-1，所以-2的二进制为110，-3的为101，结果为011）
}
